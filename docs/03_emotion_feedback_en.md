3.1. Purpose & Overview
Goal:

ì‚¬ìš©ì í–‰ë™ì„ ê¸°ë°˜ìœ¼ë¡œ ê°ì • ìƒíƒœ(ë„íŒŒë¯¼ ë¶„ë¹„ ê²½ë¡œ)ë¥¼ ê°ì§€í•˜ê³ ,

ì¦‰ê°ì ì´ê³  ì‹¬ë¦¬ì ìœ¼ë¡œ ìê·¹ì ì¸ í”¼ë“œë°±(ì• ë‹ˆë©”ì´ì…˜, ì‚¬ìš´ë“œ, ì‚¬ì´ë²„ í† í° ë³´ìƒ)ì„ ì œê³µí•˜ì—¬

â€œí–‰ìœ„ì¤‘ë… íŠ¸ë¦¬ê±°(Variableâ€Ratio Reward + Social Feedback)â€ì™€ â€œë„íŒŒë¯¼ ë£¨í”„â€ë¥¼ ê·¹ëŒ€í™”

ê¶ê·¹ì ìœ¼ë¡œ ë³¸ì‚¬ ì‚¬ì´íŠ¸ì—ì„œ íšë“í•œ ì‚¬ì´ë²„ í† í°ì„ ì•± ë‚´ ì†Œë¹„ë¡œ ì—°ê²°í•˜ê³ , ì•±ì—ì„œ ë¶€ì¡± ì‹œ ë‹¤ì‹œ ë³¸ì‚¬ë¡œ ìœ ë„í•˜ë©° ë¦¬í…ì…˜ì„ ê°•í™”í•¨.

í•µì‹¬ í¬ì¸íŠ¸
ì¦‰ê° í”¼ë“œë°±(Immediate Feedback):

ê²Œì„ ê²°ê³¼ ì§í›„ ì• ë‹ˆë©”ì´ì…˜ + ì‚¬ìš´ë“œ + í† í° ë³´ìƒ íŒ¨í‚¤ì§€

ì¬ë¯¸ ìš”ì†Œ(ì‹œê°Â·ì²­ê°)ì™€ **ì‚¬ì´ë²„ í† í° ì¦‰ì‹œ íšë“(ë˜ëŠ” ê°ì†Œ)**ë¥¼ ê²°í•©í•˜ì—¬ ì‚¬ìš©ìì˜ ë„íŒŒë¯¼ ë¶„ë¹„ë¥¼ ìœ ë°œ

í–‰ìœ„ì¤‘ë… íŠ¸ë¦¬ê±°(Behavioral Addiction Triggers):

Variableâ€Ratio Reward Schedule: ìŠ¬ë¡¯, ë£°ë ›, ê°€ì±  ë“±ì—ì„œ â€œì–¸ì œ ë‹¹ì²¨ë ì§€ ëª¨ë¦„â€ ê¸´ì¥ê°

Social Proof / Leaderboard: ì‹¤ì‹œê°„ ë­í‚¹ â†’ ê²½ìŸì‹¬ ìê·¹

Limited-Time Offer / Flash Event: â€œë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¡œê·¸ì¸ì´ 2ì‹œê°„ í›„ì— ì¢…ë£Œë©ë‹ˆë‹¤ â†’ 100í† í° ë³´ë„ˆìŠ¤â€

ì‚¬ì´ë²„ í† í° ì—°ê³„:

ë³¸ì‚¬ ì‚¬ì´íŠ¸ ì´ìš© ì‹œ íšë“ â†’ Redisì— user:{id}:cyber_token_balance ì €ì¥

ì•± ë‚´ ê²Œì„Â·ì–¸ë½ ì‹œ ì‚¬ìš© â†’ í† í° ì”ê³  ê°ì†Œ

ì”ê³  ë¶€ì¡± ì‹œ ë³¸ì‚¬ ì‚¬ì´íŠ¸ë¡œ ì¦‰ì‹œ ìœ ë„ (ë¦¬ë””ë ‰ì…˜ / í‘¸ì‹œ ì•Œë¦¼)

3.2. Emotion Matrix & Feedback Triggers
Action Type	Emotion Trigger	Reward Behavior	Feedback Message & Asset
GAME_WIN	Dopamine Surge	+10~50 ì‚¬ì´ë²„ í† í°(ëœë¤) + í™”ë ¤í•œ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ‰ ëŒ€ë°•! {earned_tokens} í† í° íšë“! ê³ ìŠ¤í”¼ë“œ í”Œë ˆì´ ê³„ì†!â€
(Confetti ì• ë‹ˆë©”ì´ì…˜ + Victory ì‚¬ìš´ë“œ)
GAME_FAIL	Frustration Loop	â€“2 ì‚¬ì´ë²„ í† í°(ì‘ì€ íŒ¨ë„í‹°) + ê²©ë ¤ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ˜“ ì•„ì‰½ë„¤ìš”â€¦ í•˜ì§€ë§Œ ê³§ ë³´ìƒì„ ë‹¤ì‹œ ë°›ì„ ìˆ˜ ìˆì–´ìš”!â€
(Sad Shake ì• ë‹ˆë©”ì´ì…˜ + Encourage ì‚¬ìš´ë“œ)
GAME_RETRY	Determination Boost	â€“1 ì‚¬ì´ë²„ í† í°(ì¬ë„ì „ ë¹„ìš©) + ì§§ì€ â€œë‹¤ì‹œ ë„ì „â€ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ”¥ í•œ ë²ˆ ë”? ì´ë²ˆì—” í™•ë¥ ì´ 15% ìƒìŠ¹í–ˆì–´ìš”!â€
(Flash ì• ë‹ˆë©”ì´ì…˜ + Beat ì‚¬ìš´ë“œ)
DAILY_INACTIVE (>12h)	Concern	í‘¸ì‹œ ì•Œë¦¼ â†’ ë³¸ì‚¬ ì‚¬ì´íŠ¸ì—ì„œ +100 í† í° ë³´ìƒ ì œì•ˆ	â€œâŒ› ì˜¤ëœë§Œì´ë„¤ìš”! ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¡œê·¸ì¸ë§Œ í•´ë„ 100í† í° ë“œë ¤ìš”!â€
(Ring í†¤ + í† í° ì´ë¯¸ì§€ ì• ë‹ˆë©”ì´ì…˜)
REWARD_CLAIM	Satisfaction	+ ì¼ì •ëŸ‰ ì‚¬ì´ë²„ í† í°(ì½˜í…ì¸  ì–¸ë½ ë³´ë„ˆìŠ¤)	â€œğŸ‘ ë³´ìƒ íšë“! {item_name} ì–¸ë½ ì™„ë£Œ. ë‹¤ìŒ ë³´ìƒê¹Œì§€ {next_threshold}í† í° ë‚¨ìŒâ€
(Unlock ì• ë‹ˆë©”ì´ì…˜ + Cheer ì‚¬ìš´ë“œ)
QUIZ_COMPLETE	Curiosity/Engagement	+200 í† í°(ë³¸ì‚¬ ì‚¬ì´íŠ¸ í€´ì¦ˆ) + ë¦¬ìŠ¤í¬ í”„ë¡œí•„ ë°˜ì˜	â€œğŸ§  í€´ì¦ˆ ì™„ë£Œ! ë‹¹ì‹ ì€ {risk_profile}í˜• í”Œë ˆì´ì–´êµ°ìš”. ë§ì¶¤ ë¦¬ì›Œë“œë¥¼ ì¶”ì²œí•´ë“œë¦´ê²Œìš”!â€

Note: ê° ìƒí™©ë³„ë¡œ â€œì• ë‹ˆë©”ì´ì…˜+ì‚¬ìš´ë“œ+í† í° ì¦ê°â€ íŒ¨í‚¤ì§€ê°€ í•œ ì„¸íŠ¸ë¡œ ë¬¶ì—¬, ìœ ì €ì˜ ê°ì • ìƒíƒœ(ë„íŒŒë¯¼ ë¶„ë¹„)ì™€ ì§ê²°ë˜ë„ë¡ ì„¤ê³„.

3.3. FastAPI Endpoint Integration

#### 3.3.1. Enhanced Emotion Feedback Endpoints

```python
# Original emotion feedback endpoint
@app.post("/api/feedback", response_model=FeedbackResponse)
def get_feedback(req: FeedbackRequest, db=Depends(get_db), redis=Depends(get_redis)):
    user = db.query(User).filter(User.id == req.user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    entry = emotion_matrix.get(req.action_type)
    if not entry:
        # ê¸°ë³¸ í”¼ë“œë°±
        return {"emotion": "neutral", "message": "ê³„ì† ì§„í–‰í•´ë³´ì„¸ìš”!", "animation": None, "sound": None, "token_delta": 0}
    
    # í† í° ì¦ê° ê³„ì‚°
    if callable(entry["token_delta"]):
        # ì—°ìŠ¹/ì—°íŒ¨ ë“± streakë¥¼ ê³ ë ¤
        streak = int(redis.get(f"user:{req.user_id}:streak_count") or 0)
        token_change = entry["token_delta"](streak)
    else:
        token_change = entry["token_delta"]
    
    # í† í° ì”ê³  ì—…ë°ì´íŠ¸
    if token_change != 0:
        redis.incrby(f"user:{req.user_id}:cyber_token_balance", token_change)
    
    # ë©”ì‹œì§€ í¬ë§·íŒ…
    formatted_message = entry["message"].format(
        earned_tokens=token_change if token_change > 0 else 0,
        item_name=req.metadata.get("item_name", ""),
        next_threshold=req.metadata.get("next_threshold", "")
    )
    
    # ë§ˆì§€ë§‰ ì•¡ì…˜ ì‹œê° ì—…ë°ì´íŠ¸
    redis.set(f"user:{req.user_id}:last_action_ts", int(datetime.utcnow().timestamp()))
    
    return {
        "emotion": entry["emotion"],
        "message": formatted_message,
        "animation": entry["animation"],
        "sound": entry["sound"],
        "token_delta": token_change
    }
# ğŸ†• Advanced AI Analysis Endpoint
@app.post("/ai/analyze", response_model=EmotionAnalysisResponse)
def analyze_emotion(req: AnalyzeRequest, db=Depends(get_db)):
    """Advanced emotion analysis with context awareness"""
    analyzer = SentimentAnalyzer()
    result = analyzer.analyze(req.text)
    
    return {
        "emotion": result.emotion,
        "score": result.score,
        "confidence": result.confidence,
        "language": result.language,
        "context_aware": bool(req.context)
    }

# ğŸ†• Personalized Feedback Generation
@app.post("/feedback/generate", response_model=PersonalizedFeedbackResponse)
def generate_feedback(req: FeedbackGenerationRequest, db=Depends(get_db)):
    """Generate emotion-based personalized feedback"""
    service = EmotionFeedbackService()
    feedback = service.generate_feedback(
        emotion=req.emotion,
        segment=req.segment,
        context=req.context
    )
    
    return {
        "success": True,
        "data": {
            "feedback": feedback["message"],
            "template_id": feedback["template_id"],
            "animation_meta": feedback["animation_meta"]
        }
    }

# ğŸ†• Personalized Recommendations
@app.get("/recommend/personalized", response_model=RecommendationResponse)
def get_personalized_recommendations(
    user_id: int = Query(...),
    emotion: Optional[str] = Query(None),
    segment: Optional[str] = Query(None)
):
    """Get AI-powered personalized game recommendations"""
    service = RecommendationService()
    recommendations = service.get_personalized_recommendations(
        user_id=user_id,
        emotion=emotion,
        segment=segment
    )
    
    return {
        "success": True,
        "data": {
            "recommendations": [
                {
                    "game_type": rec.game_type,
                    "confidence": rec.confidence,
                    "reason": rec.reason,
                    "metadata": rec.metadata
                }
                for rec in recommendations
            ]
        }
    }
```

#### 3.3.2. Enhanced Frontend Integration

```jsx
// Enhanced SlotMachine component with new endpoints
const spin = async () => {
    // 1) Game logic
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    
    // 2) Advanced emotion analysis
    const emotionData = await fetch('/ai/analyze', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            text: isWin ? "ìŠ¬ë¡¯ì—ì„œ ì´ê²¼ì–´ìš”!" : "ì•„ì‰½ê²Œ ì¡Œë„¤ìš”...",
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 3) Get personalized feedback
    const feedbackData = await fetch('/feedback/generate', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            emotion: emotionData.data.emotion,
            segment: userSegment,
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 4) Apply feedback (animation + sound + UI update)
    applyEmotionFeedback(feedbackData.data);
    
    // 5) Get next game recommendation
    const recommendations = await fetch(`/recommend/personalized?user_id=${userId}&emotion=${emotionData.data.emotion}&segment=${userSegment}`)
        .then(r => r.json());
    
    // 6) Show recommendation UI
    showGameRecommendations(recommendations.data.recommendations);
};
```

3.4. Frontend Integration (React ì˜ˆì‹œ)
3.4.1. useEmotionFeedback Hook
jsx
ë³µì‚¬
í¸ì§‘
import axios from "axios";

export async function fetchEmotionFeedback(userId, actionType, metadata = {}) {
  const response = await axios.post("/api/feedback", {
    user_id: userId,
    action_type: actionType,
    metadata: metadata
  });
  return response.data; // { emotion, message, animation, sound, token_delta }
}
3.4.2. SlotMachine ì»´í¬ë„ŒíŠ¸ ìˆ˜ì • ì˜ˆì‹œ
jsx
ë³µì‚¬
í¸ì§‘
import React, { useState, useEffect } from "react";
import { fetchEmotionFeedback } from "../hooks/useEmotionFeedback";
import useSound from "use-sound";
import Confetti from "react-confetti"; // ì˜ˆì‹œë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬
import { useSelector, useDispatch } from "react-redux";

function SlotMachine({ userId }) {
  const [reels, setReels] = useState([0, 0, 0]);
  const [streakCount, setStreakCount] = useState(0);
  const [feedback, setFeedback] = useState(null);
  const [tokenBalance, setTokenBalance] = useState(0);

  // Redux ë˜ëŠ” Contextë¡œë¶€í„° ì‚¬ì´ë²„ í† í° ì”ê³  êµ¬ë…
  const balance = useSelector(state => state.user.cyberTokenBalance);
  const dispatch = useDispatch();

  // ì‚¬ìš´ë“œ ì¤€ë¹„
  const [playVictory] = useSound("/sounds/victory.mp3");
  const [playEncourage] = useSound("/sounds/encourage.mp3");

  useEffect(() => {
    // ì´ˆê¸° í† í° ì”ê³  ë¡œë“œ
    setTokenBalance(balance);
  }, [balance]);

  const spin = async () => {
    // 1) ì‹¤ì œ ìŠ¹ë¦¬ íŒì • ë¡œì§ (variable-ratio ê¸°ë°˜)
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    const actionType = isWin ? "GAME_WIN" : "GAME_FAIL";
    const metadata = {}; // ì¶”í›„ í•„ìš”í•œ ë©”íƒ€ë°ì´í„° ì¶”ê°€

    // 2) emotion feedback ìš”ì²­
    const data = await fetchEmotionFeedback(userId, actionType, metadata);
    setFeedback(data);

    // 3) ì• ë‹ˆë©”ì´ì…˜ & ì‚¬ìš´ë“œ
    if (data.animation === "confetti") {
      // Confetti ì• ë‹ˆë©”ì´ì…˜ ë…¸ì¶œ
      // ì˜ˆ: <Confetti numberOfPieces={200} />
      playVictory();
    } else if (data.animation === "shake_sad") {
      playEncourage();
      // í™”ë©´ í”ë“¤ê¸° ë“±ì˜ ì¶”ê°€ ì´í™íŠ¸ ì²˜ë¦¬
    }

    // 4) ë ˆì¼ì¦ˆ(ë¦¬ë•ìŠ¤) í† í° ì”ê³  ì—…ë°ì´íŠ¸
    if (data.token_delta !== 0) {
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: data.token_delta });
    }

    // 5) ìŠ¤íŠ¸ë¦­(streak) ê´€ë¦¬
    if (isWin) {
      setStreakCount(prev => prev + 1);
      dispatch({ type: "UPDATE_STREAK", payload: streakCount + 1 });
    } else {
      setStreakCount(0);
      dispatch({ type: "UPDATE_STREAK", payload: 0 });
    }

    // 6) ë¦¬ì½¤ë³´ ì‹ í˜¸: ë‹¤ìŒ ì•¡ì…˜ ì˜ˆê³  (ex: GAME_RETRY ê¶Œì¥)
    if (!isWin && streakCount >= 2) {
      const retryFeedback = await fetchEmotionFeedback(userId, "GAME_RETRY", {});
      // í™”ë©´ì— â€œí•œ ë²ˆ ë”â€ í† ìŠ¤íŠ¸ ë…¸ì¶œ
      setFeedback(retryFeedback);
      playEncourage();
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: retryFeedback.token_delta });
    }

    // 7) ë¦´ ì¶œë ¥ (0~9 ëœë¤)
    setReels([
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
    ]);
  };

  return (
    <div>
      <h2>Slot Machine</h2>
      <div className="reels">
        {reels.map((num, idx) => (
          <div key={idx} className="reel">{num}</div>
        ))}
      </div>
      <button onClick={spin}>Spin</button>
      {feedback && (
        <div className={`feedback ${feedback.emotion}`}>
          {feedback.message}
        </div>
      )}
      <div>Streak: {streakCount}</div>
      <div>Cyber Token Balance: {tokenBalance}</div>
    </div>
  );
}

export default SlotMachine;
ì£¼ìš” íŠ¹ì§•:

GAME_WIN ì‹œ â€œë„íŒŒë¯¼ ì„œì§€â€ íŠ¸ë¦¬ê±° â†’ í™”ë ¤í•œ ì½˜í˜í‹° + í† í° ë³´ìƒ

GAME_FAIL ì‹œ â€œì¢Œì ˆ â†’ ì¬ë„ì „â€ ë£¨í”„ í™œì„±í™” â†’ ì†ŒëŸ‰ í† í° ì°¨ê° í›„ â€œí•œ ë²ˆ ë”â€ ìœ ë„

ë¦¬ë•ìŠ¤/ì»¨í…ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì‚¬ì´ë²„ í† í° ì”ê³ ì™€ ìŠ¤íŠ¸ë¦­ ì¹´ìš´íŠ¸ë¥¼ ì „ì—­ ê´€ë¦¬

3.5. Psychometric/Survey í”¼ë“œë°± ì—°ë™
í€´ì¦ˆ ì™„ë£Œ(Quiz Complete) ì‹œ /api/feedback í˜¸ì¶œ â†’ QUIZ_COMPLETE

ë¦¬ìŠ¤í¬ í”„ë¡œí•„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ í”¼ë“œë°± ë©”ì‹œì§€ + +200 í† í° ë³´ìƒ

ë„íŒŒë¯¼ í”¼ë“œë°±: ì• ë‹ˆë©”ì´ì…˜ â€œquiz_successâ€ + (think.mp3) ì‚¬ìš´ë“œ

ì´í›„ ê°œì¸í™” ì¶”ì²œ (02 ë¬¸ì„œì˜ Recommendation Engine)ì—ì„œ risk_profile í™œìš©

3.6. ìš”ì•½
ìœ ì € í–‰ë™ â†’ FastAPI /api/feedback í˜¸ì¶œ â†’

ë„íŒŒë¯¼ ë£¨í”„(ì• ë‹ˆë©”ì´ì…˜ + ì‚¬ìš´ë“œ + í† í° ì¦ê°) í™œì„±í™” â†’

ì‚¬ì´ë²„ í† í° ì”ê³ ê°€ ë³€ë™ë˜ë©´ ì¦‰ì‹œ Redux/Redis â†’ UI ì—…ë°ì´íŠ¸ â†’

ì”ê³  ë¶€ì¡± ì‹œ ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¦¬ë””ë ‰ì…˜ â†’ ë¦¬í…ì…˜ ê³ ë¦¬ ì™„ì„±

<!-- English translation below -->

# Emotion Feedback (English Translation)

3.1. Purpose & Overview
Goal:

To detect emotional states (dopamine secretion pathways) based on user behavior, and

To provide immediate and psychologically stimulating feedback (animations, sounds, cyber token rewards) to maximize

"Behavioral Addiction Triggers (Variable-Ratio Reward + Social Feedback)" and "Dopamine Loops"

Ultimately, to connect the cyber tokens acquired on the headquarters site to consumption within the app, and to redirect to the headquarters when lacking in the app, thereby strengthening retention.

Key Points
Immediate Feedback:

Animation + Sound + Token Reward Package immediately after game results

Combining fun elements (visual and auditory) with **immediate acquisition (or reduction) of cyber tokens** to induce dopamine secretion in users

Behavioral Addiction Triggers:

Variable-Ratio Reward Schedule: Uncertainty of "when will I win" in slots, roulette, gacha, etc.

Social Proof / Leaderboard: Real-time rankings â†’ Stimulate competitiveness

Limited-Time Offer / Flash Event: "Headquarters site login ends in 2 hours â†’ 100 token bonus"

Linkage with Cyber Tokens:

Acquired when using the headquarters site â†’ Stored in Redis as user:{id}:cyber_token_balance

Used in-app games/unlocks â†’ Decrease in token balance

Immediate guidance to the headquarters site when the balance is insufficient (redirection/push notification)

3.2. Emotion Matrix & Feedback Triggers
Action Type	Emotion Trigger	Reward Behavior	Feedback Message & Asset
GAME_WIN	Dopamine Surge	+10~50 ì‚¬ì´ë²„ í† í°(ëœë¤) + í™”ë ¤í•œ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ‰ ëŒ€ë°•! {earned_tokens} í† í° íšë“! ê³ ìŠ¤í”¼ë“œ í”Œë ˆì´ ê³„ì†!â€
(Confetti ì• ë‹ˆë©”ì´ì…˜ + Victory ì‚¬ìš´ë“œ)
GAME_FAIL	Frustration Loop	â€“2 ì‚¬ì´ë²„ í† í°(ì‘ì€ íŒ¨ë„í‹°) + ê²©ë ¤ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ˜“ ì•„ì‰½ë„¤ìš”â€¦ í•˜ì§€ë§Œ ê³§ ë³´ìƒì„ ë‹¤ì‹œ ë°›ì„ ìˆ˜ ìˆì–´ìš”!â€
(Sad Shake ì• ë‹ˆë©”ì´ì…˜ + Encourage ì‚¬ìš´ë“œ)
GAME_RETRY	Determination Boost	â€“1 ì‚¬ì´ë²„ í† í°(ì¬ë„ì „ ë¹„ìš©) + ì§§ì€ â€œë‹¤ì‹œ ë„ì „â€ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ”¥ í•œ ë²ˆ ë”? ì´ë²ˆì—” í™•ë¥ ì´ 15% ìƒìŠ¹í–ˆì–´ìš”!â€
(Flash ì• ë‹ˆë©”ì´ì…˜ + Beat ì‚¬ìš´ë“œ)
DAILY_INACTIVE (>12h)	Concern	í‘¸ì‹œ ì•Œë¦¼ â†’ ë³¸ì‚¬ ì‚¬ì´íŠ¸ì—ì„œ +100 í† í° ë³´ìƒ ì œì•ˆ	â€œâŒ› ì˜¤ëœë§Œì´ë„¤ìš”! ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¡œê·¸ì¸ë§Œ í•´ë„ 100í† í° ë“œë ¤ìš”!â€
(Ring í†¤ + í† í° ì´ë¯¸ì§€ ì• ë‹ˆë©”ì´ì…˜)
REWARD_CLAIM	Satisfaction	+ ì¼ì •ëŸ‰ ì‚¬ì´ë²„ í† í°(ì½˜í…ì¸  ì–¸ë½ ë³´ë„ˆìŠ¤)	â€œğŸ‘ ë³´ìƒ íšë“! {item_name} ì–¸ë½ ì™„ë£Œ. ë‹¤ìŒ ë³´ìƒê¹Œì§€ {next_threshold}í† í° ë‚¨ìŒâ€
(Unlock ì• ë‹ˆë©”ì´ì…˜ + Cheer ì‚¬ìš´ë“œ)
QUIZ_COMPLETE	Curiosity/Engagement	+200 í† í°(ë³¸ì‚¬ ì‚¬ì´íŠ¸ í€´ì¦ˆ) + ë¦¬ìŠ¤í¬ í”„ë¡œí•„ ë°˜ì˜	â€œğŸ§  í€´ì¦ˆ ì™„ë£Œ! ë‹¹ì‹ ì€ {risk_profile}í˜• í”Œë ˆì´ì–´êµ°ìš”. ë§ì¶¤ ë¦¬ì›Œë“œë¥¼ ì¶”ì²œí•´ë“œë¦´ê²Œìš”!â€

Note: Each situation is designed as a set of "Animation + Sound + Token Change" packages, directly linked to the user's emotional state (dopamine secretion).

3.3. FastAPI Endpoint Integration

#### 3.3.1. Enhanced Emotion Feedback Endpoints

```python
# Original emotion feedback endpoint
@app.post("/api/feedback", response_model=FeedbackResponse)
def get_feedback(req: FeedbackRequest, db=Depends(get_db), redis=Depends(get_redis)):
    user = db.query(User).filter(User.id == req.user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    entry = emotion_matrix.get(req.action_type)
    if not entry:
        # Default feedback
        return {"emotion": "neutral", "message": "ê³„ì† ì§„í–‰í•´ë³´ì„¸ìš”!", "animation": None, "sound": None, "token_delta": 0}
    
    # Calculate token change
    if callable(entry["token_delta"]):
        # Considering streaks like winning/losing streaks
        streak = int(redis.get(f"user:{req.user_id}:streak_count") or 0)
        token_change = entry["token_delta"](streak)
    else:
        token_change = entry["token_delta"]
    
    # Update token balance
    if token_change != 0:
        redis.incrby(f"user:{req.user_id}:cyber_token_balance", token_change)
    
    # Format message
    formatted_message = entry["message"].format(
        earned_tokens=token_change if token_change > 0 else 0,
        item_name=req.metadata.get("item_name", ""),
        next_threshold=req.metadata.get("next_threshold", "")
    )
    
    # Update last action timestamp
    redis.set(f"user:{req.user_id}:last_action_ts", int(datetime.utcnow().timestamp()))
    
    return {
        "emotion": entry["emotion"],
        "message": formatted_message,
        "animation": entry["animation"],
        "sound": entry["sound"],
        "token_delta": token_change
    }
# ğŸ†• Advanced AI Analysis Endpoint
@app.post("/ai/analyze", response_model=EmotionAnalysisResponse)
def analyze_emotion(req: AnalyzeRequest, db=Depends(get_db)):
    """Advanced emotion analysis with context awareness"""
    analyzer = SentimentAnalyzer()
    result = analyzer.analyze(req.text)
    
    return {
        "emotion": result.emotion,
        "score": result.score,
        "confidence": result.confidence,
        "language": result.language,
        "context_aware": bool(req.context)
    }

# ğŸ†• Personalized Feedback Generation
@app.post("/feedback/generate", response_model=PersonalizedFeedbackResponse)
def generate_feedback(req: FeedbackGenerationRequest, db=Depends(get_db)):
    """Generate emotion-based personalized feedback"""
    service = EmotionFeedbackService()
    feedback = service.generate_feedback(
        emotion=req.emotion,
        segment=req.segment,
        context=req.context
    )
    
    return {
        "success": True,
        "data": {
            "feedback": feedback["message"],
            "template_id": feedback["template_id"],
            "animation_meta": feedback["animation_meta"]
        }
    }

# ğŸ†• Personalized Recommendations
@app.get("/recommend/personalized", response_model=RecommendationResponse)
def get_personalized_recommendations(
    user_id: int = Query(...),
    emotion: Optional[str] = Query(None),
    segment: Optional[str] = Query(None)
):
    """Get AI-powered personalized game recommendations"""
    service = RecommendationService()
    recommendations = service.get_personalized_recommendations(
        user_id=user_id,
        emotion=emotion,
        segment=segment
    )
    
    return {
        "success": True,
        "data": {
            "recommendations": [
                {
                    "game_type": rec.game_type,
                    "confidence": rec.confidence,
                    "reason": rec.reason,
                    "metadata": rec.metadata
                }
                for rec in recommendations
            ]
        }
    }
```

#### 3.3.2. Enhanced Frontend Integration

```jsx
// Enhanced SlotMachine component with new endpoints
const spin = async () => {
    // 1) Game logic
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    
    // 2) Advanced emotion analysis
    const emotionData = await fetch('/ai/analyze', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            text: isWin ? "ìŠ¬ë¡¯ì—ì„œ ì´ê²¼ì–´ìš”!" : "ì•„ì‰½ê²Œ ì¡Œë„¤ìš”...",
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 3) Get personalized feedback
    const feedbackData = await fetch('/feedback/generate', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            emotion: emotionData.data.emotion,
            segment: userSegment,
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 4) Apply feedback (animation + sound + UI update)
    applyEmotionFeedback(feedbackData.data);
    
    // 5) Get next game recommendation
    const recommendations = await fetch(`/recommend/personalized?user_id=${userId}&emotion=${emotionData.data.emotion}&segment=${userSegment}`)
        .then(r => r.json());
    
    // 6) Show recommendation UI
    showGameRecommendations(recommendations.data.recommendations);
};
```

3.4. Frontend Integration (React ì˜ˆì‹œ)
3.4.1. useEmotionFeedback Hook
jsx
ë³µì‚¬
í¸ì§‘
import axios from "axios";

export async function fetchEmotionFeedback(userId, actionType, metadata = {}) {
  const response = await axios.post("/api/feedback", {
    user_id: userId,
    action_type: actionType,
    metadata: metadata
  });
  return response.data; // { emotion, message, animation, sound, token_delta }
}
3.4.2. SlotMachine ì»´í¬ë„ŒíŠ¸ ìˆ˜ì • ì˜ˆì‹œ
jsx
ë³µì‚¬
í¸ì§‘
import React, { useState, useEffect } from "react";
import { fetchEmotionFeedback } from "../hooks/useEmotionFeedback";
import useSound from "use-sound";
import Confetti from "react-confetti"; // ì˜ˆì‹œë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬
import { useSelector, useDispatch } from "react-redux";

function SlotMachine({ userId }) {
  const [reels, setReels] = useState([0, 0, 0]);
  const [streakCount, setStreakCount] = useState(0);
  const [feedback, setFeedback] = useState(null);
  const [tokenBalance, setTokenBalance] = useState(0);

  // Redux ë˜ëŠ” Contextë¡œë¶€í„° ì‚¬ì´ë²„ í† í° ì”ê³  êµ¬ë…
  const balance = useSelector(state => state.user.cyberTokenBalance);
  const dispatch = useDispatch();

  // ì‚¬ìš´ë“œ ì¤€ë¹„
  const [playVictory] = useSound("/sounds/victory.mp3");
  const [playEncourage] = useSound("/sounds/encourage.mp3");

  useEffect(() => {
    // ì´ˆê¸° í† í° ì”ê³  ë¡œë“œ
    setTokenBalance(balance);
  }, [balance]);

  const spin = async () => {
    // 1) ì‹¤ì œ ìŠ¹ë¦¬ íŒì • ë¡œì§ (variable-ratio ê¸°ë°˜)
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    const actionType = isWin ? "GAME_WIN" : "GAME_FAIL";
    const metadata = {}; // ì¶”í›„ í•„ìš”í•œ ë©”íƒ€ë°ì´í„° ì¶”ê°€

    // 2) emotion feedback ìš”ì²­
    const data = await fetchEmotionFeedback(userId, actionType, metadata);
    setFeedback(data);

    // 3) ì• ë‹ˆë©”ì´ì…˜ & ì‚¬ìš´ë“œ
    if (data.animation === "confetti") {
      // Confetti ì• ë‹ˆë©”ì´ì…˜ ë…¸ì¶œ
      // ì˜ˆ: <Confetti numberOfPieces={200} />
      playVictory();
    } else if (data.animation === "shake_sad") {
      playEncourage();
      // í™”ë©´ í”ë“¤ê¸° ë“±ì˜ ì¶”ê°€ ì´í™íŠ¸ ì²˜ë¦¬
    }

    // 4) ë ˆì¼ì¦ˆ(ë¦¬ë•ìŠ¤) í† í° ì”ê³  ì—…ë°ì´íŠ¸
    if (data.token_delta !== 0) {
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: data.token_delta });
    }

    // 5) ìŠ¤íŠ¸ë¦­(streak) ê´€ë¦¬
    if (isWin) {
      setStreakCount(prev => prev + 1);
      dispatch({ type: "UPDATE_STREAK", payload: streakCount + 1 });
    } else {
      setStreakCount(0);
      dispatch({ type: "UPDATE_STREAK", payload: 0 });
    }

    // 6) ë¦¬ì½¤ë³´ ì‹ í˜¸: ë‹¤ìŒ ì•¡ì…˜ ì˜ˆê³  (ex: GAME_RETRY ê¶Œì¥)
    if (!isWin && streakCount >= 2) {
      const retryFeedback = await fetchEmotionFeedback(userId, "GAME_RETRY", {});
      // í™”ë©´ì— â€œí•œ ë²ˆ ë”â€ í† ìŠ¤íŠ¸ ë…¸ì¶œ
      setFeedback(retryFeedback);
      playEncourage();
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: retryFeedback.token_delta });
    }

    // 7) ë¦´ ì¶œë ¥ (0~9 ëœë¤)
    setReels([
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
    ]);
  };

  return (
    <div>
      <h2>Slot Machine</h2>
      <div className="reels">
        {reels.map((num, idx) => (
          <div key={idx} className="reel">{num}</div>
        ))}
      </div>
      <button onClick={spin}>Spin</button>
      {feedback && (
        <div className={`feedback ${feedback.emotion}`}>
          {feedback.message}
        </div>
      )}
      <div>Streak: {streakCount}</div>
      <div>Cyber Token Balance: {tokenBalance}</div>
    </div>
  );
}

export default SlotMachine;
ì£¼ìš” íŠ¹ì§•:

GAME_WIN ì‹œ â€œë„íŒŒë¯¼ ì„œì§€â€ íŠ¸ë¦¬ê±° â†’ í™”ë ¤í•œ ì½˜í˜í‹° + í† í° ë³´ìƒ

GAME_FAIL ì‹œ â€œì¢Œì ˆ â†’ ì¬ë„ì „â€ ë£¨í”„ í™œì„±í™” â†’ ì†ŒëŸ‰ í† í° ì°¨ê° í›„ â€œí•œ ë²ˆ ë”â€ ìœ ë„

ë¦¬ë•ìŠ¤/ì»¨í…ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì‚¬ì´ë²„ í† í° ì”ê³ ì™€ ìŠ¤íŠ¸ë¦­ ì¹´ìš´íŠ¸ë¥¼ ì „ì—­ ê´€ë¦¬

3.5. Psychometric/Survey í”¼ë“œë°± ì—°ë™
í€´ì¦ˆ ì™„ë£Œ(Quiz Complete) ì‹œ /api/feedback í˜¸ì¶œ â†’ QUIZ_COMPLETE

ë¦¬ìŠ¤í¬ í”„ë¡œí•„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ í”¼ë“œë°± ë©”ì‹œì§€ + +200 í† í° ë³´ìƒ

ë„íŒŒë¯¼ í”¼ë“œë°±: ì• ë‹ˆë©”ì´ì…˜ â€œquiz_successâ€ + (think.mp3) ì‚¬ìš´ë“œ

ì´í›„ ê°œì¸í™” ì¶”ì²œ (02 ë¬¸ì„œì˜ Recommendation Engine)ì—ì„œ risk_profile í™œìš©

3.6. ìš”ì•½
ìœ ì € í–‰ë™ â†’ FastAPI /api/feedback í˜¸ì¶œ â†’

ë„íŒŒë¯¼ ë£¨í”„(ì• ë‹ˆë©”ì´ì…˜ + ì‚¬ìš´ë“œ + í† í° ì¦ê°) í™œì„±í™” â†’

ì‚¬ì´ë²„ í† í° ì”ê³ ê°€ ë³€ë™ë˜ë©´ ì¦‰ì‹œ Redux/Redis â†’ UI ì—…ë°ì´íŠ¸ â†’

ì”ê³  ë¶€ì¡± ì‹œ ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¦¬ë””ë ‰ì…˜ â†’ ë¦¬í…ì…˜ ê³ ë¦¬ ì™„ì„±

<!-- English translation below -->

# Emotion Feedback (English Translation)

3.1. Purpose & Overview
Goal:

To detect emotional states (dopamine secretion pathways) based on user behavior, and

To provide immediate and psychologically stimulating feedback (animations, sounds, cyber token rewards) to maximize

"Behavioral Addiction Triggers (Variable-Ratio Reward + Social Feedback)" and "Dopamine Loops"

Ultimately, to connect the cyber tokens acquired on the headquarters site to consumption within the app, and to redirect to the headquarters when lacking in the app, thereby strengthening retention.

Key Points
Immediate Feedback:

Animation + Sound + Token Reward Package immediately after game results

Combining fun elements (visual and auditory) with **immediate acquisition (or reduction) of cyber tokens** to induce dopamine secretion in users

Behavioral Addiction Triggers:

Variable-Ratio Reward Schedule: Uncertainty of "when will I win" in slots, roulette, gacha, etc.

Social Proof / Leaderboard: Real-time rankings â†’ Stimulate competitiveness

Limited-Time Offer / Flash Event: "Headquarters site login ends in 2 hours â†’ 100 token bonus"

Linkage with Cyber Tokens:

Acquired when using the headquarters site â†’ Stored in Redis as user:{id}:cyber_token_balance

Used in-app games/unlocks â†’ Decrease in token balance

Immediate guidance to the headquarters site when the balance is insufficient (redirection/push notification)

3.2. Emotion Matrix & Feedback Triggers
Action Type	Emotion Trigger	Reward Behavior	Feedback Message & Asset
GAME_WIN	Dopamine Surge	+10~50 ì‚¬ì´ë²„ í† í°(ëœë¤) + í™”ë ¤í•œ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ‰ ëŒ€ë°•! {earned_tokens} í† í° íšë“! ê³ ìŠ¤í”¼ë“œ í”Œë ˆì´ ê³„ì†!â€
(Confetti ì• ë‹ˆë©”ì´ì…˜ + Victory ì‚¬ìš´ë“œ)
GAME_FAIL	Frustration Loop	â€“2 ì‚¬ì´ë²„ í† í°(ì‘ì€ íŒ¨ë„í‹°) + ê²©ë ¤ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ˜“ ì•„ì‰½ë„¤ìš”â€¦ í•˜ì§€ë§Œ ê³§ ë³´ìƒì„ ë‹¤ì‹œ ë°›ì„ ìˆ˜ ìˆì–´ìš”!â€
(Sad Shake ì• ë‹ˆë©”ì´ì…˜ + Encourage ì‚¬ìš´ë“œ)
GAME_RETRY	Determination Boost	â€“1 ì‚¬ì´ë²„ í† í°(ì¬ë„ì „ ë¹„ìš©) + ì§§ì€ â€œë‹¤ì‹œ ë„ì „â€ ì• ë‹ˆë©”ì´ì…˜	â€œğŸ”¥ í•œ ë²ˆ ë”? ì´ë²ˆì—” í™•ë¥ ì´ 15% ìƒìŠ¹í–ˆì–´ìš”!â€
(Flash ì• ë‹ˆë©”ì´ì…˜ + Beat ì‚¬ìš´ë“œ)
DAILY_INACTIVE (>12h)	Concern	í‘¸ì‹œ ì•Œë¦¼ â†’ ë³¸ì‚¬ ì‚¬ì´íŠ¸ì—ì„œ +100 í† í° ë³´ìƒ ì œì•ˆ	â€œâŒ› ì˜¤ëœë§Œì´ë„¤ìš”! ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¡œê·¸ì¸ë§Œ í•´ë„ 100í† í° ë“œë ¤ìš”!â€
(Ring í†¤ + í† í° ì´ë¯¸ì§€ ì• ë‹ˆë©”ì´ì…˜)
REWARD_CLAIM	Satisfaction	+ ì¼ì •ëŸ‰ ì‚¬ì´ë²„ í† í°(ì½˜í…ì¸  ì–¸ë½ ë³´ë„ˆìŠ¤)	â€œğŸ‘ ë³´ìƒ íšë“! {item_name} ì–¸ë½ ì™„ë£Œ. ë‹¤ìŒ ë³´ìƒê¹Œì§€ {next_threshold}í† í° ë‚¨ìŒâ€
(Unlock ì• ë‹ˆë©”ì´ì…˜ + Cheer ì‚¬ìš´ë“œ)
QUIZ_COMPLETE	Curiosity/Engagement	+200 í† í°(ë³¸ì‚¬ ì‚¬ì´íŠ¸ í€´ì¦ˆ) + ë¦¬ìŠ¤í¬ í”„ë¡œí•„ ë°˜ì˜	â€œğŸ§  í€´ì¦ˆ ì™„ë£Œ! ë‹¹ì‹ ì€ {risk_profile}í˜• í”Œë ˆì´ì–´êµ°ìš”. ë§ì¶¤ ë¦¬ì›Œë“œë¥¼ ì¶”ì²œí•´ë“œë¦´ê²Œìš”!â€

Note: Each situation is designed as a set of "Animation + Sound + Token Change" packages, directly linked to the user's emotional state (dopamine secretion).

3.3. FastAPI Endpoint Integration

#### 3.3.1. Enhanced Emotion Feedback Endpoints

```python
# Original emotion feedback endpoint
@app.post("/api/feedback", response_model=FeedbackResponse)
def get_feedback(req: FeedbackRequest, db=Depends(get_db), redis=Depends(get_redis)):
    user = db.query(User).filter(User.id == req.user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    entry = emotion_matrix.get(req.action_type)
    if not entry:
        # Default feedback
        return {"emotion": "neutral", "message": "ê³„ì† ì§„í–‰í•´ë³´ì„¸ìš”!", "animation": None, "sound": None, "token_delta": 0}
    
    # Calculate token change
    if callable(entry["token_delta"]):
        # Considering streaks like winning/losing streaks
        streak = int(redis.get(f"user:{req.user_id}:streak_count") or 0)
        token_change = entry["token_delta"](streak)
    else:
        token_change = entry["token_delta"]
    
    # Update token balance
    if token_change != 0:
        redis.incrby(f"user:{req.user_id}:cyber_token_balance", token_change)
    
    # Format message
    formatted_message = entry["message"].format(
        earned_tokens=token_change if token_change > 0 else 0,
        item_name=req.metadata.get("item_name", ""),
        next_threshold=req.metadata.get("next_threshold", "")
    )
    
    # Update last action timestamp
    redis.set(f"user:{req.user_id}:last_action_ts", int(datetime.utcnow().timestamp()))
    
    return {
        "emotion": entry["emotion"],
        "message": formatted_message,
        "animation": entry["animation"],
        "sound": entry["sound"],
        "token_delta": token_change
    }
# ğŸ†• Advanced AI Analysis Endpoint
@app.post("/ai/analyze", response_model=EmotionAnalysisResponse)
def analyze_emotion(req: AnalyzeRequest, db=Depends(get_db)):
    """Advanced emotion analysis with context awareness"""
    analyzer = SentimentAnalyzer()
    result = analyzer.analyze(req.text)
    
    return {
        "emotion": result.emotion,
        "score": result.score,
        "confidence": result.confidence,
        "language": result.language,
        "context_aware": bool(req.context)
    }

# ğŸ†• Personalized Feedback Generation
@app.post("/feedback/generate", response_model=PersonalizedFeedbackResponse)
def generate_feedback(req: FeedbackGenerationRequest, db=Depends(get_db)):
    """Generate emotion-based personalized feedback"""
    service = EmotionFeedbackService()
    feedback = service.generate_feedback(
        emotion=req.emotion,
        segment=req.segment,
        context=req.context
    )
    
    return {
        "success": True,
        "data": {
            "feedback": feedback["message"],
            "template_id": feedback["template_id"],
            "animation_meta": feedback["animation_meta"]
        }
    }

# ğŸ†• Personalized Recommendations
@app.get("/recommend/personalized", response_model=RecommendationResponse)
def get_personalized_recommendations(
    user_id: int = Query(...),
    emotion: Optional[str] = Query(None),
    segment: Optional[str] = Query(None)
):
    """Get AI-powered personalized game recommendations"""
    service = RecommendationService()
    recommendations = service.get_personalized_recommendations(
        user_id=user_id,
        emotion=emotion,
        segment=segment
    )
    
    return {
        "success": True,
        "data": {
            "recommendations": [
                {
                    "game_type": rec.game_type,
                    "confidence": rec.confidence,
                    "reason": rec.reason,
                    "metadata": rec.metadata
                }
                for rec in recommendations
            ]
        }
    }
```

#### 3.3.2. Enhanced Frontend Integration

```jsx
// Enhanced SlotMachine component with new endpoints
const spin = async () => {
    // 1) Game logic
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    
    // 2) Advanced emotion analysis
    const emotionData = await fetch('/ai/analyze', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            text: isWin ? "ìŠ¬ë¡¯ì—ì„œ ì´ê²¼ì–´ìš”!" : "ì•„ì‰½ê²Œ ì¡Œë„¤ìš”...",
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 3) Get personalized feedback
    const feedbackData = await fetch('/feedback/generate', {
        method: 'POST',
        body: JSON.stringify({
            user_id: userId,
            emotion: emotionData.data.emotion,
            segment: userSegment,
            context: { game_type: "slot", result: isWin ? "win" : "loss" }
        })
    }).then(r => r.json());
    
    // 4) Apply feedback (animation + sound + UI update)
    applyEmotionFeedback(feedbackData.data);
    
    // 5) Get next game recommendation
    const recommendations = await fetch(`/recommend/personalized?user_id=${userId}&emotion=${emotionData.data.emotion}&segment=${userSegment}`)
        .then(r => r.json());
    
    // 6) Show recommendation UI
    showGameRecommendations(recommendations.data.recommendations);
};
```

3.4. Frontend Integration (React ì˜ˆì‹œ)
3.4.1. useEmotionFeedback Hook
jsx
ë³µì‚¬
í¸ì§‘
import axios from "axios";

export async function fetchEmotionFeedback(userId, actionType, metadata = {}) {
  const response = await axios.post("/api/feedback", {
    user_id: userId,
    action_type: actionType,
    metadata: metadata
  });
  return response.data; // { emotion, message, animation, sound, token_delta }
}
3.4.2. SlotMachine ì»´í¬ë„ŒíŠ¸ ìˆ˜ì • ì˜ˆì‹œ
jsx
ë³µì‚¬
í¸ì§‘
import React, { useState, useEffect } from "react";
import { fetchEmotionFeedback } from "../hooks/useEmotionFeedback";
import useSound from "use-sound";
import Confetti from "react-confetti"; // ì˜ˆì‹œë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬
import { useSelector, useDispatch } from "react-redux";

function SlotMachine({ userId }) {
  const [reels, setReels] = useState([0, 0, 0]);
  const [streakCount, setStreakCount] = useState(0);
  const [feedback, setFeedback] = useState(null);
  const [tokenBalance, setTokenBalance] = useState(0);

  // Redux ë˜ëŠ” Contextë¡œë¶€í„° ì‚¬ì´ë²„ í† í° ì”ê³  êµ¬ë…
  const balance = useSelector(state => state.user.cyberTokenBalance);
  const dispatch = useDispatch();

  // ì‚¬ìš´ë“œ ì¤€ë¹„
  const [playVictory] = useSound("/sounds/victory.mp3");
  const [playEncourage] = useSound("/sounds/encourage.mp3");

  useEffect(() => {
    // ì´ˆê¸° í† í° ì”ê³  ë¡œë“œ
    setTokenBalance(balance);
  }, [balance]);

  const spin = async () => {
    // 1) ì‹¤ì œ ìŠ¹ë¦¬ íŒì • ë¡œì§ (variable-ratio ê¸°ë°˜)
    const isWin = Math.random() < (0.10 + Math.min(streakCount * 0.01, 0.30));
    const actionType = isWin ? "GAME_WIN" : "GAME_FAIL";
    const metadata = {}; // ì¶”í›„ í•„ìš”í•œ ë©”íƒ€ë°ì´í„° ì¶”ê°€

    // 2) emotion feedback ìš”ì²­
    const data = await fetchEmotionFeedback(userId, actionType, metadata);
    setFeedback(data);

    // 3) ì• ë‹ˆë©”ì´ì…˜ & ì‚¬ìš´ë“œ
    if (data.animation === "confetti") {
      // Confetti ì• ë‹ˆë©”ì´ì…˜ ë…¸ì¶œ
      // ì˜ˆ: <Confetti numberOfPieces={200} />
      playVictory();
    } else if (data.animation === "shake_sad") {
      playEncourage();
      // í™”ë©´ í”ë“¤ê¸° ë“±ì˜ ì¶”ê°€ ì´í™íŠ¸ ì²˜ë¦¬
    }

    // 4) ë ˆì¼ì¦ˆ(ë¦¬ë•ìŠ¤) í† í° ì”ê³  ì—…ë°ì´íŠ¸
    if (data.token_delta !== 0) {
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: data.token_delta });
    }

    // 5) ìŠ¤íŠ¸ë¦­(streak) ê´€ë¦¬
    if (isWin) {
      setStreakCount(prev => prev + 1);
      dispatch({ type: "UPDATE_STREAK", payload: streakCount + 1 });
    } else {
      setStreakCount(0);
      dispatch({ type: "UPDATE_STREAK", payload: 0 });
    }

    // 6) ë¦¬ì½¤ë³´ ì‹ í˜¸: ë‹¤ìŒ ì•¡ì…˜ ì˜ˆê³  (ex: GAME_RETRY ê¶Œì¥)
    if (!isWin && streakCount >= 2) {
      const retryFeedback = await fetchEmotionFeedback(userId, "GAME_RETRY", {});
      // í™”ë©´ì— â€œí•œ ë²ˆ ë”â€ í† ìŠ¤íŠ¸ ë…¸ì¶œ
      setFeedback(retryFeedback);
      playEncourage();
      dispatch({ type: "UPDATE_TOKEN_BALANCE", payload: retryFeedback.token_delta });
    }

    // 7) ë¦´ ì¶œë ¥ (0~9 ëœë¤)
    setReels([
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
      Math.floor(Math.random() * 10),
    ]);
  };

  return (
    <div>
      <h2>Slot Machine</h2>
      <div className="reels">
        {reels.map((num, idx) => (
          <div key={idx} className="reel">{num}</div>
        ))}
      </div>
      <button onClick={spin}>Spin</button>
      {feedback && (
        <div className={`feedback ${feedback.emotion}`}>
          {feedback.message}
        </div>
      )}
      <div>Streak: {streakCount}</div>
      <div>Cyber Token Balance: {tokenBalance}</div>
    </div>
  );
}

export default SlotMachine;
ì£¼ìš” íŠ¹ì§•:

GAME_WIN ì‹œ â€œë„íŒŒë¯¼ ì„œì§€â€ íŠ¸ë¦¬ê±° â†’ í™”ë ¤í•œ ì½˜í˜í‹° + í† í° ë³´ìƒ

GAME_FAIL ì‹œ â€œì¢Œì ˆ â†’ ì¬ë„ì „â€ ë£¨í”„ í™œì„±í™” â†’ ì†ŒëŸ‰ í† í° ì°¨ê° í›„ â€œí•œ ë²ˆ ë”â€ ìœ ë„

ë¦¬ë•ìŠ¤/ì»¨í…ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ì‚¬ì´ë²„ í† í° ì”ê³ ì™€ ìŠ¤íŠ¸ë¦­ ì¹´ìš´íŠ¸ë¥¼ ì „ì—­ ê´€ë¦¬

3.5. Psychometric/Survey í”¼ë“œë°± ì—°ë™
í€´ì¦ˆ ì™„ë£Œ(Quiz Complete) ì‹œ /api/feedback í˜¸ì¶œ â†’ QUIZ_COMPLETE

ë¦¬ìŠ¤í¬ í”„ë¡œí•„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ í”¼ë“œë°± ë©”ì‹œì§€ + +200 í† í° ë³´ìƒ

ë„íŒŒë¯¼ í”¼ë“œë°±: ì• ë‹ˆë©”ì´ì…˜ â€œquiz_successâ€ + (think.mp3) ì‚¬ìš´ë“œ

ì´í›„ ê°œì¸í™” ì¶”ì²œ (02 ë¬¸ì„œì˜ Recommendation Engine)ì—ì„œ risk_profile í™œìš©

3.6. ìš”ì•½
ìœ ì € í–‰ë™ â†’ FastAPI /api/feedback í˜¸ì¶œ â†’

ë„íŒŒë¯¼ ë£¨í”„(ì• ë‹ˆë©”ì´ì…˜ + ì‚¬ìš´ë“œ + í† í° ì¦ê°) í™œì„±í™” â†’

ì‚¬ì´ë²„ í† í° ì”ê³ ê°€ ë³€ë™ë˜ë©´ ì¦‰ì‹œ Redux/Redis â†’ UI ì—…ë°ì´íŠ¸ â†’

ì”ê³  ë¶€ì¡± ì‹œ ë³¸ì‚¬ ì‚¬ì´íŠ¸ ë¦¬ë””ë ‰ì…˜ â†’ ë¦¬í…ì…˜ ê³ ë¦¬ ì™„ì„±

